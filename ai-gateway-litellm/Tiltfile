# -*- mode: Python -*-

version_settings(constraint='>=0.23.0')

# Increase the default k8s upsert timeout to accommodate CRD installations
update_settings(k8s_upsert_timeout_secs=300)

# Create Kubernetes secrets from environment variables
load('ext://secret', 'secret_from_dict')

# Configure Tilt to work with AI Gateway Operator's custom AiGateway CRDs
k8s_kind(
    'AiGateway',
    # Operator creates pods asynchronously after AiGateway CRD creation and Tilt
    # must wait for operator-managed pods rather than assuming immediate readiness
    pod_readiness='wait',
)

def ai_gateway_litellm_install(version="0.2.0", operator=True, instance=True):
    if operator:
        ai_gateway_litellm_operator_install(version=version)
    if instance:
        ai_gateway_litellm_instance_install()


def ai_gateway_litellm_operator_install(version="0.2.0"):
    """
    Installs the ai gateway litellm operators into your cluster.
    """

    install_url = "https://github.com/agentic-layer/ai-gateway-litellm-operator/releases/download/v%s/install.yaml"

    # Deploy AI Gateway LiteLLM Operator
    wait_cmd = """
kubectl wait --for=condition=Available --timeout=300s -n ai-gateway-litellm-system deployment/ai-gateway-litellm-controller-manager 1>&2
"""

    delete_cmd = [
        "kubectl", "delete", "--ignore-not-found",

        # Kubernetes is prone to deadlocks when you delete CRDs and namespaces at the same time:
        # - The Namespace controller thinks it's responsible for deleting all resources in its namespace.
        # - The CRD controller deletes the API routes for deleting resources.
        # So the namespace controller blocks and eventually times out.
        #
        # To prevent this from slowing down 'tilt down', we do a --wait=false when deleting
        # CRDs+Namespaces together.
        "--wait=false",
        "-f", install_url % version
    ]

    k8s_custom_deploy(
        'ai-gateway-litellm-operator',
        deps=[],
        apply_cmd="""
set -ex
kubectl apply -f %s -o yaml
set +e
""" % (install_url % version) + wait_cmd,
        delete_cmd=delete_cmd,
    )

    k8s_resource(
        'ai-gateway-litellm-operator',
        labels=['ai-gateway-litellm-operator'],
        resource_deps=['cert-manager', 'agent-runtime'],
    )


def ai_gateway_litellm_instance_install():
    """
    Deploys an AI Gateway instance into your cluster.
    """

    google_api_key = os.environ.get('GOOGLE_API_KEY', '')
    if not google_api_key:
        fail('GOOGLE_API_KEY environment variable is required. Please set it in your shell or .env file.')

    k8s_yaml(secret_from_dict(
        name = "api-key-secrets",
        namespace = "ai-gateway",
        # The ai-gateway expects the API key to be called <provider>_API_KEY
        inputs = { "GEMINI_API_KEY": google_api_key }
    ))

    # Get the directory of this Tiltfile to reference files relative to the extension
    extension_dir = os.path.dirname(__file__)

    k8s_yaml(os.path.join(extension_dir, 'ai-gateway.yaml'))

    k8s_resource(
        'ai-gateway-litellm',
        labels=['ai-gateway-litellm'],
        resource_deps=['ai-gateway-litellm-operator']
    )
